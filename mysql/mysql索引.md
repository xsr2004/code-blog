### 什么是mysql索引，mysql索引是如何工作的

数据库的数据都是保存在磁盘的，操作其需要io流。

而索引就是用一个附带数据来记录某个磁盘块中的位置，避免了全表scan

类似目录，空间换时间

而B+树则更类似类似章-节-段架构



### 索引有哪些类型

如果按照一般情况的话：分为主键索引，唯一索引，组合索引

如果按照存储方式来分：分为聚簇索引，非聚簇索引

如果按照数据结构来分：分为B+树索引，哈希索引



### mysql索引的innoDB存储引擎为什么是B+树，什么是B树

它是为了存储索引和数据的不同结构

- B树是一种多叉平找树

  - 它在平衡二叉树的基础上添加了多分支，这让每一层的节点可以存储更多的索引和数据。减少了io操作的次数。

  - 等值查找时：时间复杂度为o(logn)

  - 范围查找就一言难尽了。
- B+树是mysql的innoDB存储引擎默认的索引存储数据结构，它是一种**多叉平衡查找树**(多叉AVL)
  - 它的非叶子节点不再是存储索引和数据，而是只有索引；并且叶子节点之间用双向指针去连接
  - 这样的好处就是：可能覆盖索引；范围查找很快

### 树的高度和磁盘IO次数的关系

树的高度=磁盘IO次数

数据库的数据和索引存储在磁盘中，在处理时需要调入内存，这个过程就是磁盘IO做的事情。

在innoDB中，不考虑mysql的连接器，查询缓存，解析器，优化器和执行器制定执行计划，你的全世界只有索引和数据时，

查找数据应该是：

- 先操作IO，从磁盘中找到这个索引。调入内存
- 再操作IO，通过索引将对应的数据查出，调入内存

> 注意这里我以2层B+树举例，而一般都会“索引找索引”的

还要注意：[MySQL](https://www.yunqiic.com/tag/mysql/)的InnoDB存储引擎在设计时是将根节点常驻内存的。

### 主键索引，辅助索引的查询流程

主键索引：innoDB默认主键索引，叶子节点是这个主键和数据本身，非叶子节点就是主键(索引)

![image-20240417214045627](D:\picGo\images\image-20240417214045627.png)



辅助索引：innoDB如果我们手动添加其他列的索引，那么这个索引就是辅助索引，采用的是非聚簇索引的存储方式，也就是索引本身和数据不在一起存储，索引的value是数据的存储位置，在innoDB一般就是主键id。

那么通过辅助索引去找数据时就会经历下面流程

- 1.根据辅助索引去找主键
- 2.根据主键重新io查询主键索引的树（回表）

### 什么是联合索引，最左匹配原则如何在联合索引中体现？

组合索引：innoDB中如果我们设置一个索引，然后它的相关列有多个，这时这个索引就是组合索引。它遵循最左匹配原则。B+树的叶子节点是根据a>b>c的优先级来的，比如a从小到大排序（不管bc），a排完再排bc。

当用select去尝试命中时，如果不是根据最左前缀匹配，比如我要查b=？c=？，那就索引无法命中，因为没有给出a。

![image-20240417215013764](D:\picGo\images\image-20240417215013764.png)

### 什么是覆盖索引

是一种优化的手段

因为在根据辅助索引去查数据时，往往要先查出id再去“回表”查主键索引的树。

而如果我要查索引本身的列时，这时查到辅助索引树的叶子节点时就可以直接返回。

> **如果我们查询的结果只需要a、b、c这三个字段，那我们使用这个idx_index(a，b，c)组合索引查询到叶子节点时就可以直接返回了**



### 如何避免回表？

设计索引时尽量去用一些经常被select的列去当这个辅助索引/组合索引。



### 为什么使用索引会加快查询？

索引相当于书的目录，多用一点存储空间去记录数据的位置，数据库就可以直接通过索引去io读取出对应的数据，而不是全表的scan，减少磁盘io操作的时间和占用次数。

### 为什么B+树的增删效率更高

因为B+树有很多冗余节点，而且叶子节点又是用链表连接的。

所以B+树在删除一个节点时：

- 如果这个节点的值仅是叶子节点，不是非叶子节点的值，直接链表中删除即可
- 如果这个节点的值是叶子节点，又是非叶子节点的值，则删除链表中的该叶子节点，再删除一个根节点。

B+树基本不会动，插入也是如此。

而反观B树，B树没有冗余节点，且要删除一个节点，则可能发生整个树的”变形“。插入也是如此。



### 那一棵 B+树能存储多少条数据呢？

InnoDB存储引擎最小存储单元是页，在B+树索引结构里，页可以放一行一行的数据（叶子节点），也可以放主键+指针（非叶子节点）

数据库从磁盘io查一次会查N*一页16k的数据

MySQL从磁盘加载数据是按照页来读取的，即便你查询一条数据，它也会读取一页16k的数据出来

假设主键是bigint8B，而指针6B。那么每一个节点是一页，如果这个节点是非叶子节点，那就是8+6=14B，一页就可以存放16k/14B=1170个指针+主键。如果这个节点是叶子节点，一条数据1k的话，可以保存16k/1k=16条。

如果B+树有2层，可以存储的数据就是1170页*16条=18000+

如果有3层，可以存储的数据就是1170页* *1170页*  * 16=2000w+。

### 索引哪些情况下会失效呢

- 在索引列上使用函数或表达式
- 使用！=或者not，因为不走索引
- or的左右涉及不同的索引
- 数据库优化器估计全表快于索引时，会直接用全表查询
- 组合索引不满足最左前缀
- like '%xxx'会导致查询模糊不清，因为这样代表查询任意开头的数据，而索引本身是确定的，数据库需要遍历大量的索引来确定你要的那个“%”。这可能比全表还慢，所以这时索引肯定失效。

### 创建索引有哪些注意点？

1.选择合适的列去做索引：比如select，orderby，groupby的一些字段

2.避免过多的索引：维护索引需要成本，rud时所有的索引都将被更新，占用过多的存储位置

3.利用前缀匹配来确定索引的顺序：比如字符串类型的列，可以用前缀索引来减少索引存储的大小

4.选择长度较小的字段去做索引：因为在innoDB的非聚簇索引B+树中，每个非叶子节点是由索引+主键组成的，而每个节点都是一个磁盘页（其大小有限为16K），如果字段过长，就会导致树变高，IO操作变多。

### 适合建索引的情况



### 索引不适合哪些场景呢？

1.数据表较小：300以上数据量才建议建立索引，建也是白建，mysql优化器不会走索引的

2.频繁更新的列：因为更新很可能导致索引也要更新，索引区分度要高



### 适合创建索引的10种情况

1.具有唯一性约束的字段。创建具有唯一性约束的字段时也会自动创建该字段的索引。

2.频繁作为where查询条件的字段

3.经常被当做group by 或 order by条件的字段

4.被DISTINCT修饰的字段

5.在多表连接时，对用于连接的字段创建索引。

6.尽量使用字段类型占空间小的字段创建索引，因为页空间有限，在页数比较庞大时，能够缩小一点因为类型导致的空间都是不小的优化。

7.使用字符串前缀创建索引。在阿里巴巴的Java开发手册中明确指出，在堆Varchar字段创建索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。

8.区分度高的字段适合创建索引

9.使用最频繁的列适合放在联合索引的左边，（最左前缀原则），可以增加联合索引的命中率

10，在多个字段都要创建索引的情况下，联合索引优于单列索引

### 不适合创建索引的5种情况

1.不作为where条件的字段不要创建索引

2.在数据量小的情况下，不要创建索引

3.在有大量重复数据的列，不要创建索引，比如性别

4.避免对经常更新的表创建过多的索引，因为更新很可能导致索引也要更新，消耗系统资源

5.避免对无序的字段创建索引

### innoDB对B+树索引的一些小设置

1.[MySQL](https://www.yunqiic.com/tag/mysql/)的InnoDB存储引擎在设计时是将根节点常驻内存的

可以通过设置innodb_buffer_pool_size来确认内存可以最多放多大的索引数据（一般默认128M）

2.在建立索引的时候要对表进行全表的扫描工作

frm表结构，ibd表数据



### 实际操作索引吗？索引文件在哪里？





参考部分（有价值的）：

https://developer.aliyun.com/article/831250

https://javabetter.cn/sidebar/sanfene/mysql.html#_42-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E4%BC%98%E5%8C%96

https://www.runoob.com/mysql/mysql-index.html

https://www.cnblogs.com/yifanSJ/p/17662132.html

https://juejin.cn/post/6904293886626103309

https://tech.meituan.com/2014/06/30/mysql-index.html

一条sql是如何执行的：https://www.xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84

https://blog.csdn.net/m0_54714490/article/details/128076083

https://tech.meituan.com/2014/06/30/mysql-index.html